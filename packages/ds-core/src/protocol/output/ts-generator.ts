/**
 * Color Set Protocol (CSP) - TypeScript Generator
 * Generates TypeScript constants from resolved color sets
 */

import type { ResolvedColorSet, ResolvedColorTokens, OutputOptions } from '../schema.js';

/**
 * Convert kebab-case to camelCase
 */
function toCamelCase(str: string): string {
  return str.replace(/-([a-z0-9])/g, (_, char) => char.toUpperCase());
}

/**
 * Convert kebab-case to PascalCase
 */
export function toPascalCase(str: string): string {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

/**
 * Generate TypeScript constants for color tokens
 */
export function generateTypeScriptConstants(
  tokens: ResolvedColorTokens,
  options: OutputOptions = {}
): string {
  const { includeComments = false } = options;

  const lines: string[] = [];

  if (includeComments) {
    lines.push('/**');
    lines.push(' * Color tokens - Generated by Color Set Protocol (CSP)');
    lines.push(' */');
    lines.push('');
  }

  for (const [name, value] of Object.entries(tokens)) {
    const constName = toCamelCase(name);

    if (includeComments) {
      lines.push(`/** ${name} */`);
    }
    lines.push(`export const ${constName} = '${value}' as const;`);
  }

  return lines.join('\n');
}

/**
 * Generate a TypeScript object with all tokens
 */
export function generateTypeScriptObject(
  resolved: ResolvedColorSet,
  options: OutputOptions = {}
): string {
  const { includeComments = true } = options;

  const lines: string[] = [];
  const objectName = toCamelCase(resolved.id) + 'Theme';

  if (includeComments) {
    lines.push('/**');
    lines.push(` * ${resolved.name}`);
    lines.push(` * Mode: ${resolved.mode}`);
    lines.push(' * Generated by Color Set Protocol (CSP)');
    lines.push(' */');
  }

  lines.push(`export const ${objectName} = {`);
  lines.push(`  id: '${resolved.id}',`);
  lines.push(`  name: '${resolved.name}',`);
  lines.push(`  mode: '${resolved.mode}',`);
  lines.push('  tokens: {');

  for (const [name, value] of Object.entries(resolved.tokens)) {
    lines.push(`    '${name}': '${value}',`);
  }

  lines.push('  },');
  lines.push('} as const;');

  return lines.join('\n');
}

/**
 * Generate TypeScript type for token names
 */
export function generateTypeScriptTypes(
  tokens: ResolvedColorTokens,
  options: OutputOptions = {}
): string {
  const { includeComments = true } = options;

  const lines: string[] = [];

  if (includeComments) {
    lines.push('/**');
    lines.push(' * Color token names - Generated by Color Set Protocol (CSP)');
    lines.push(' */');
  }

  const tokenNames = Object.keys(tokens);

  lines.push('export type ColorTokenName =');
  for (let i = 0; i < tokenNames.length; i++) {
    const isLast = i === tokenNames.length - 1;
    lines.push(`  | '${tokenNames[i]}'${isLast ? ';' : ''}`);
  }

  lines.push('');

  if (includeComments) {
    lines.push('/**');
    lines.push(' * Color token values map type');
    lines.push(' */');
  }

  lines.push('export type ColorTokens = Record<ColorTokenName, string>;');

  return lines.join('\n');
}

/**
 * Generate a complete TypeScript module with all themes
 */
export function generateTypeScriptModule(
  themes: ResolvedColorSet[],
  options: OutputOptions = {}
): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(' * Color Set Protocol (CSP) - Generated Theme Definitions');
  lines.push(' * Do not edit manually');
  lines.push(' */');
  lines.push('');

  // Generate types first
  const firstTheme = themes[0];
  if (firstTheme) {
    lines.push(generateTypeScriptTypes(firstTheme.tokens, { includeComments: false }));
    lines.push('');
  }

  // Generate theme objects
  for (const theme of themes) {
    lines.push(generateTypeScriptObject(theme, options));
    lines.push('');
  }

  // Generate themes map
  lines.push('/**');
  lines.push(' * All available themes');
  lines.push(' */');
  lines.push('export const themes = {');
  for (const theme of themes) {
    const objectName = toCamelCase(theme.id) + 'Theme';
    lines.push(`  '${theme.id}': ${objectName},`);
  }
  lines.push('} as const;');
  lines.push('');

  // Generate theme IDs type
  lines.push('/**');
  lines.push(' * Available theme IDs');
  lines.push(' */');
  lines.push('export type ThemeId = keyof typeof themes;');

  return lines.join('\n');
}

/**
 * Generate TypeScript file content
 */
export function generateTypeScriptFile(
  themes: ResolvedColorSet[],
  options: OutputOptions = {}
): string {
  return generateTypeScriptModule(themes, options);
}

/**
 * Generate CSS variable getter function
 */
export function generateCSSVarHelper(
  prefix: string = 'wg-color',
  options: OutputOptions = {}
): string {
  const { includeComments = true } = options;

  const lines: string[] = [];

  if (includeComments) {
    lines.push('/**');
    lines.push(' * Get a CSS custom property reference for a color token');
    lines.push(' * @param token - The color token name');
    lines.push(' * @returns CSS var() reference');
    lines.push(' */');
  }

  lines.push(`export function getColorVar(token: ColorTokenName): string {`);
  lines.push(`  return \`var(--${prefix}-\${token})\`;`);
  lines.push('}');

  return lines.join('\n');
}
